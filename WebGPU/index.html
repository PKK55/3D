<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8" />
        <title>WebGPU Life</title>
    </head>
    <body>
        <canvas width="512" height="512"></canvas>
        <script type="module">
            const canvas = document.querySelector('canvas')
            const GRID_SIZE = 32

            if (!navigator.gpu) {
                throw new Error('WebGPU not supported on this browser.')
            }

            const adapter = await navigator.gpu.requestAdapter()
            if (!adapter) {
                throw new Error('No appropriate GPUAdapter found.')
            }

            const device = await adapter.requestDevice()

            const context = canvas.getContext('webgpu')
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
            context.configure({
                device: device,
                format: canvasFormat,
            })

            // Create an array representing the active state of each cell.
            const cellStateArray = new Uint32Array(GRID_SIZE * GRID_SIZE)
            // Create a storage buffer to hold the cell state.
            const cellStateStorage = [
                device.createBuffer({
                    label: 'Cell State A',
                    size: cellStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }),
                device.createBuffer({
                    label: 'Cell State B',
                    size: cellStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }),
            ]
            // Mark every third cell of the grid as active.
            for (let i = 0; i < cellStateArray.length; i += 3) {
                cellStateArray[i] = 1
            }
            device.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray)
            for (let i = 0; i < cellStateArray.length; i++) {
                cellStateArray[i] = i % 2
            }
            device.queue.writeBuffer(cellStateStorage[1], 0, cellStateArray)

            const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE])
            const uniformBuffer = device.createBuffer({
                label: 'Grid Uniforms',
                size: uniformArray.byteLength,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            })
            device.queue.writeBuffer(uniformBuffer, 0, uniformArray)

            const vertices = new Float32Array([
                //   X,    Y,
                // Triangle 1 (Blue)
                -0.8, -0.8, 0.8, -0.8, 0.8, 0.8,
                // Triangle 2 (Red)
                -0.8, -0.8, 0.8, 0.8, -0.8, 0.8,
            ])
            const vertexBuffer = device.createBuffer({
                label: 'Cell vertices',
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            })
            device.queue.writeBuffer(
                vertexBuffer,
                /*bufferOffset=*/ 0,
                vertices
            )

            const vertexBufferLayout = {
                arrayStride: 8, //GPUが次の頂点のデータを取得する際にバッファ内でスキップする必要があるバイト数、32ビット浮動小数点値は 4バイトなので、2つで 8バイト
                attributes: [
                    {
                        format: 'float32x2', // GPUVertexFormat リストから指定
                        offset: 0,
                        shaderLocation: 0, // Position、シェーダーで利用
                    },
                ],
            }

            const cellShaderModule = device.createShaderModule({
                label: 'Cell shader',
                code: `
                    @group(0) @binding(0) var<uniform> grid: vec2f;
                    @group(0) @binding(1) var<storage> cellState: array<u32>;

                    //頂点シェーダー
                    struct VertexInput {
                        @location(0) pos: vec2f,
                        @builtin(instance_index) instance: u32,
                    };

                    struct VertexOutput {
                        @builtin(position) pos: vec4f,
                        @location(0) cell: vec2f,
                    };

                    @vertex
                    fn vertexMain(input: VertexInput) -> VertexOutput {
                        let i = f32(input.instance); // Save the instance_index as a float
                        let state = f32(cellState[input.instance]);
                        let cell = vec2f(i % grid.x, floor(i / grid.x));
                        let cellOffset = cell / grid * 2;
                        let gridPos = (input.pos * state + 1) / grid - 1 + cellOffset;

                        var output: VertexOutput;
                        output.pos = vec4f(gridPos, 0, 1); //(X, Y, Z, W)
                        output.cell = cell;
                        return output;
                    }

                    //フラグメントシェーダー
                    @fragment
                    fn fragmentMain(@location(0) cell: vec2f) -> @location(0) vec4f {
                        return vec4f(cell/grid, 1-(cell.x + cell.y)/2, 1);
                        // Remember, fragment return values are (Red, Green, Blue, Alpha)
                        // and since cell is a 2D vector, this is equivalent to:
                        // (Red = cell.x, Green = cell.y, Blue = 0, Alpha = 1)
                    }
                `,
            })

            const WORKGROUP_SIZE = 8
            const simulationShaderModule = device.createShaderModule({
                label: 'Game of Life simulation shader',
                code: `
                    @group(0) @binding(0) var<uniform> grid: vec2f;
                    @group(0) @binding(1) var<storage> cellStateIn: array<u32>;
                    @group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;
                        
                    fn cellIndex(cell: vec2u) -> u32 {
                        return cell.y * u32(grid.x) + cell.x;
                    }
                    
                    @compute
                    @workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE}) 
                    fn computeMain(@builtin(global_invocation_id) cell: vec3u) {
                        if (cellStateIn[cellIndex(cell.xy)] == 1) {
                            cellStateOut[cellIndex(cell.xy)] = 0;
                        } 
                        else {
                            cellStateOut[cellIndex(cell.xy)] = 1;
                        }
                    }
                `,
            })

            //コンピュートシェーダーのバインドグループ
            const bindGroupLayout = device.createBindGroupLayout({
                label: 'Cell Bind Group Layout',
                entries: [
                    {
                        binding: 0,
                        visibility:
                            GPUShaderStage.VERTEX| GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,
                        buffer: {}, // Grid uniform buffer
                    },
                    {
                        binding: 1,
                        visibility:
                            GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
                        buffer: { type: 'read-only-storage' }, // Cell state input buffer
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'storage' }, // Cell state output buffer
                    },
                ],
            })

            const bindGroups = [
                device.createBindGroup({
                    label: 'Cell renderer bind group A',
                    // layout: cellPipeline.getBindGroupLayout(0),
                    layout: bindGroupLayout,
                    entries: [
                        {
                            binding: 0,
                            resource: { buffer: uniformBuffer },
                        },
                        {
                            binding: 1,
                            resource: { buffer: cellStateStorage[0] },
                        },
                        {
                            binding: 2,
                            resource: { buffer: cellStateStorage[1] },
                        },
                    ],
                }),
                device.createBindGroup({
                    label: 'Cell renderer bind group B',
                    layout: bindGroupLayout,
                    entries: [
                        {
                            binding: 0,
                            resource: { buffer: uniformBuffer },
                        },
                        {
                            binding: 1,
                            resource: { buffer: cellStateStorage[1] },
                        },
                        {
                            binding: 2,
                            resource: { buffer: cellStateStorage[0] },
                        },
                    ],
                }),
            ]

            const pipelineLayout = device.createPipelineLayout({
                label: 'Cell Pipeline Layout',
                bindGroupLayouts: [bindGroupLayout],
            })

            //レンダリングパイプラインの作成
            const cellPipeline = device.createRenderPipeline({
                label: 'Cell pipeline',
                layout: pipelineLayout,
                vertex: {
                    module: cellShaderModule,
                    entryPoint: 'vertexMain',
                    buffers: [vertexBufferLayout],
                },
                fragment: {
                    module: cellShaderModule,
                    entryPoint: 'fragmentMain',
                    targets: [
                        {
                            format: canvasFormat,
                        },
                    ],
                },
            })

            // Create a compute pipeline that updates the game state.
            const simulationPipeline = device.createComputePipeline({
                label: 'Simulation pipeline',
                layout: pipelineLayout,
                compute: {
                    module: simulationShaderModule,
                    entryPoint: 'computeMain',
                },
            })

            const UPDATE_INTERVAL = 200 // Update every 200ms (5 times/sec)
            let step = 0 // Track how many simulation steps have been run

            // rendering code
            function updateGrid() {
                const encoder = device.createCommandEncoder()

                const computePass = encoder.beginComputePass()
                computePass.setPipeline(simulationPipeline)
                computePass.setBindGroup(0, bindGroups[step % 2])

                const workgroupCount = Math.ceil(GRID_SIZE / WORKGROUP_SIZE)
                computePass.dispatchWorkgroups(workgroupCount, workgroupCount)

                computePass.end()

                step++ // Increment the step count

                // Start a render pass
                const pass = encoder.beginRenderPass({
                    colorAttachments: [
                        {
                            view: context.getCurrentTexture().createView(),
                            loadOp: 'clear',
                            clearValue: { r: 0, g: 0, b: 0.4, a: 1 },
                            storeOp: 'store',
                        },
                    ],
                })

                // draw the grid
                pass.setPipeline(cellPipeline)
                pass.setBindGroup(0, bindGroups[step % 2])
                pass.setVertexBuffer(0, vertexBuffer)
                pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE) // 6 vertices, 2 triangles

                // End the render pass and submit the command buffer
                pass.end()
                device.queue.submit([encoder.finish()])
            }

            // schedule updateGrid() to run repeatedly
            setInterval(updateGrid, UPDATE_INTERVAL)
        </script>
    </body>
</html>

<!-- 参考にしたサイト
https://codelabs.developers.google.com/your-first-webgpu-app?hl=ja#3 -->
